// DÁN NGUYÊN KHỐI NÀY VÀO CONSOLE 1 LẦN
(async function () {
    if (!window.cc || !cc.director || !cc.director.getScene) {
        console.warn('[testBetTx] Không thấy cc / scene');
        return;
    }

    const TAIL_BTN_TAI = 'MiniGameScene/MiniGameNode/TopUI/TxGameLive/Main/borderTabble/nodeSprite/btnCuocTai';
    const TAIL_BTN_XIU = 'MiniGameScene/MiniGameNode/TopUI/TxGameLive/Main/borderTabble/nodeSprite/btnCuocXiu';

    const TAIL_ROW2 = 'TxGameLive/Main/borderTabble/ChatController/TipDealer/tabTipDealer/TipContent/views/contentChat/row2/itemTip/lbMoney';
    const TAIL_ROW1 = 'TxGameLive/Main/borderTabble/ChatController/TipDealer/tabTipDealer/TipContent/views/contentChat/row1/itemTip/lbMoney';
    const TAIL_ROW0 = 'TxGameLive/Main/borderTabble/ChatController/TipDealer/tabTipDealer/TipContent/views/contentChat/row0/itemTip/lbMoney';

    // Mapping phỉnh (amount -> tail + text)
    const CHIP_CONFIG = [
        // row0
        { amount: 10000000, txt: '10M', tailEnd: TAIL_ROW0 },
        { amount:  5000000, txt: '5M',  tailEnd: TAIL_ROW0 },
        { amount:  2000000, txt: '2M',  tailEnd: TAIL_ROW0 },

        // row1
        { amount:  1000000, txt: '1M',   tailEnd: TAIL_ROW1 },
        { amount:   500000, txt: '500K', tailEnd: TAIL_ROW1 },
        { amount:   200000, txt: '200K', tailEnd: TAIL_ROW1 },
        { amount:   100000, txt: '100K', tailEnd: TAIL_ROW1 },
        { amount:    50000, txt: '50K',  tailEnd: TAIL_ROW1 },

        // row2
        { amount:    20000, txt: '20K', tailEnd: TAIL_ROW2 },
        { amount:    10000, txt: '10K', tailEnd: TAIL_ROW2 },
        { amount:     5000, txt: '5K',  tailEnd: TAIL_ROW2 },
        { amount:     2000, txt: '2K',  tailEnd: TAIL_ROW2 },
        { amount:     1000, txt: '1K',  tailEnd: TAIL_ROW2 }
    ];

    function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
    }

    function tailOf(node, limit) {
        limit = limit || 16;
        const names = [];
        let n = node, c = 0;
        while (n && c < 64) {
            if (n.name) names.push(n.name);
            n = n.parent;
            c++;
        }
        names.reverse();
        return names.slice(-limit).join('/');
    }

    function walkNodes(cb) {
        const scene = cc.director.getScene();
        if (!scene) return;
        const q = [scene];
        const seen = new Set();
        while (q.length) {
            const n = q.shift();
            if (!n || seen.has(n)) continue;
            seen.add(n);
            try { cb(n); } catch (e) { }
            const kids = n.children || n._children || [];
            for (let i = 0; i < kids.length; i++) {
                if (kids[i] && !seen.has(kids[i])) q.push(kids[i]);
            }
        }
    }

    function hasBtn(n)  { return !!(n && n.getComponent && n.getComponent(cc.Button)); }
    function hasTgl(n)  { return !!(n && n.getComponent && n.getComponent(cc.Toggle)); }
    function clickable(n) { return hasBtn(n) || hasTgl(n) || n._touchListener; }

    function clickableOf(node, depth) {
        depth = depth || 5;
        let cur = node, d = 0;
        while (cur && d <= depth) {
            if (clickable(cur)) return cur;
            cur = cur.parent;
            d++;
        }
        return node;
    }

    function emitClick(node) {
        if (!node) return false;

        const btn = node.getComponent && node.getComponent(cc.Button);
        if (btn && btn.interactable !== false) {
            try {
                cc.Component.EventHandler.emitEvents(
                    btn.clickEvents,
                    new cc.Event.EventCustom('click', true)
                );
            } catch (e) { }
            return true;
        }

        const tg = node.getComponent && node.getComponent(cc.Toggle);
        if (tg && tg.interactable !== false) {
            try {
                tg.isChecked = true;
                tg._emitToggleEvents && tg._emitToggleEvents();
            } catch (e) { }
            return true;
        }

        try {
            const cam = cc.Camera.findCamera(node);
            const sp  = cam.worldToScreen(
                node.convertToWorldSpaceAR(cc.v2())
            );
            const fs = cc.view.getFrameSize();
            const vs = cc.view.getVisibleSize();
            const x = sp.x * (fs.width  / vs.width);
            const y = sp.y * (fs.height / vs.height);
            const cvs = document.querySelector('canvas');
            if (!cvs) return false;

            cvs.dispatchEvent(new PointerEvent('pointerdown', {
                clientX: x,
                clientY: y,
                buttons: 1,
                bubbles: true
            }));
            cvs.dispatchEvent(new PointerEvent('pointerup', {
                clientX: x,
                clientY: y,
                buttons: 1,
                bubbles: true
            }));
            return true;
        } catch (e) {
            console.warn('[emitClick] fallback error', e);
            return false;
        }
    }

    function findLabelByTailAndText(tailEnd, txt) {
        tailEnd = String(tailEnd || '').toLowerCase();
        txt     = String(txt || '').trim();
        let found = null;

        walkNodes(n => {
            if (found) return;
            const lb = (n.getComponent && (n.getComponent(cc.Label) || n.getComponent(cc.RichText))) || null;
            if (!lb || typeof lb.string === 'undefined') return;

            const s = String(lb.string || '').trim();
            if (s !== txt) return;

            const t = tailOf(n, 16);
            if (!String(t || '').toLowerCase().endsWith(tailEnd)) return;

            found = { node: n, text: s, tail: t };
        });

        return found;
    }

    function findNodeByTailEnd(tailEnd) {
        tailEnd = String(tailEnd || '').toLowerCase();
        let hit = null;
        walkNodes(n => {
            if (hit) return;
            const t = tailOf(n, 16);
            if (String(t || '').toLowerCase().endsWith(tailEnd)) {
                hit = n;
            }
        });
        return hit;
    }

    function makePlan(amount) {
        let rest = Math.max(0, Math.floor(+amount || 0));
        const steps = [];
        const cfgSorted = CHIP_CONFIG.slice().sort((a, b) => b.amount - a.amount);

        for (const cfg of cfgSorted) {
            if (rest <= 0) break;
            const cnt = Math.floor(rest / cfg.amount);
            if (cnt > 0) {
                steps.push({ cfg, count: cnt });
                rest -= cnt * cfg.amount;
            }
        }
        return { steps, rest };
    }

    async function clickChipOnce(cfg) {
        const label = findLabelByTailAndText(cfg.tailEnd, cfg.txt);
        if (!label || !label.node) {
            console.warn('[testBetTx] Không tìm thấy label phỉnh', cfg);
            return false;
        }
        const node = clickableOf(label.node, 5);
        const ok   = emitClick(node);
        if (!ok) {
            console.warn('[testBetTx] click phỉnh thất bại', cfg);
            return false;
        }
        return true;
    }

    async function clickSide(side) {
        const tail = (String(side || '').toUpperCase() === 'TAI')
            ? TAIL_BTN_TAI
            : TAIL_BTN_XIU;

        const node = findNodeByTailEnd(tail);
        if (!node) {
            console.warn('[testBetTx] Không tìm thấy nút cửa', side, 'tailEnd =', tail);
            return false;
        }
        const ok = emitClick(clickableOf(node, 5));
        if (!ok) console.warn('[testBetTx] click cửa thất bại', side);
        return ok;
    }

    // HÀM PUBLIC: gọi từ console
    window.testBetTx = async function (amount, side) {
        side = String(side || '').toUpperCase();
        if (side !== 'TAI' && side !== 'XIU') {
            console.warn('Side phải là "TAI" hoặc "XIU"');
            return;
        }

        const raw = Math.max(0, Math.floor(+amount || 0));
        if (!raw) {
            console.warn('[testBetTx] amount = 0');
            return;
        }

        const { steps, rest } = makePlan(raw);
        if (!steps.length || rest > 0) {
            console.warn('[testBetTx] Không tách được số tiền', raw,
                'bằng bộ phỉnh TipDealer. rest =', rest);
            return;
        }

        console.log('[testBetTx] side =', side, 'amount =', raw, 'plan =', steps.map(
            s => `${s.count}×${s.cfg.txt}`
        ).join(' + '));

        for (const step of steps) {
            for (let i = 0; i < step.count; i++) {
                const okChip = await clickChipOnce(step.cfg);
                if (!okChip) return;

                await sleep(150);

                const okSide = await clickSide(side);
                if (!okSide) return;

                await sleep(180);
            }
        }

        console.log('[testBetTx] DONE', { side, amount: raw });
    };

    console.log('%c[testBetTx] ĐÃ KHAI BÁO. Ví dụ:  testBetTx(10000, "TAI")', 'color:#0f0');
})();
